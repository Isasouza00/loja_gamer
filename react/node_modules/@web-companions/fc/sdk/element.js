import{AF}from"../hooks";import{defMapper}from"../utils";export function EG(config){const mapper=config.mapper||defMapper;return func=>{const element=build(func,config.props||{},config.render,mapper,config.shadow);return(name,options)=>{try{customElements.define(name,element,options)}catch(e){console.warn(e)}const component=async _p=>customElements.whenDefined(name).then(()=>customElements.get(name));return component.element=element,component.adapter=(func,defaultProps)=>func(name,defaultProps),component}}}function build(func,props,render,mapper,shadow){var _a;const customEl=((_a=class extends HTMLElement{constructor(){super(),this._props={};const ctr=void 0!==shadow?this.attachShadow(shadow):this;this.aFunc=AF(func,r=>render(r,ctr));for(const pK in props){const pV=props[pK];let attr=void 0;"type"in pV&&(this.props[pK]=pV.default,attr=pV.attribute),Reflect.defineProperty(this,pK,{get:()=>this.props[pK],set:value=>{this.props=mapper.apply(this,[this.props,pK,value,attr])},enumerable:!0})}}static get observedAttributes(){return Object.values(this.attributes)}set props(newProps){void 0!==newProps&&this.props!==newProps&&(this._props=newProps,this.render())}get props(){return this._props}connectedCallback(){this.render()}attributeChangedCallback(name,oldValue,newValue){if(oldValue!==newValue)for(const[attrKey,attrName]of Object.entries(this.constructor.attributes))if(attrName===name&&this[attrKey]!==newValue){this[attrKey]=newValue;break}}render(){this.isConnected&&Reflect.apply(this.aFunc,this,[this.props])}}).attributes={},_a),attributes=Reflect.get(customEl,"attributes");for(const pK in props){const pV=props[pK];"type"in pV&&void 0!==pV.attribute&&Reflect.defineProperty(customEl,"attributes",{value:{...attributes,[pK]:pV.attribute},enumerable:!0,writable:!0})}return customEl}
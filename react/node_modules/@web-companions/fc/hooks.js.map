{"version":3,"file":"hooks.js","sourceRoot":"","sources":["../src/hooks.ts"],"names":[],"mappings":"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","sourcesContent":["import { fnWrap } from './utils';\n\ntype Bucket = {\n  /** nextStateSlotIdx */\n  nSSI: number;\n\n  /** nextEffectIdx */\n  nEI: number;\n\n  /** nextMemoizationIdx */\n  nMI: number;\n\n  /** stateSlots */\n  sS: [any, any][];\n\n  /** effects */\n  e: any[];\n\n  /** memoizations */\n  m: any[];\n\n  /** hasUpdatedState shows if a state was changed */\n  hUS: boolean;\n\n  /** cleanups */\n  c: (Function | undefined)[];\n\n  /** articulated function */\n  af: Function;\n};\n\nconst buckets = new WeakMap<Function, Bucket>();\nconst afStack: Function[] = [];\n\nfunction getCurrentBucket() {\n  const af = afStack[afStack.length - 1];\n  const bucket = buckets.get(af);\n  if (bucket !== undefined) {\n    return bucket;\n  } else {\n    throw new Error('Hooks only valid inside an Articulated Function or a Custom Hook.');\n  }\n}\n\n// NOTE: both `guards1` and `guards2` are either\n//    `undefined` or an array\nfunction guardsChanged(guards1: any[] | undefined, guards2: any[] | undefined) {\n  // either guards list not set?\n  if (guards1 === undefined || guards2 === undefined) {\n    // force assumption of change in guards\n    return true;\n  }\n\n  // guards lists of different length?\n  if (guards1.length !== guards2.length) {\n    // guards changed\n    return true;\n  }\n\n  // check guards lists for differences\n  //    (only shallow value comparisons)\n  for (const [idx, guard] of guards1.entries()) {\n    if (!Object.is(guard, guards2[idx])) {\n      // guards changed\n      return true;\n    }\n  }\n\n  // assume no change in guards\n  return false;\n}\n\n////////////////////////////////////////////////////////\n\nexport function AF<T extends Function, R>(fns: T, cb: (r: any) => R) {\n  af.reset = reset;\n  return af;\n\n  function af(this: any, ...args: any[]): R {\n    afStack.push(af);\n\n    let bucket = buckets.get(af);\n    if (bucket == null) {\n      bucket = {\n        nSSI: 0,\n        nEI: 0,\n        nMI: 0,\n        sS: [],\n        e: [],\n        c: [],\n        m: [],\n        hUS: false,\n        af: af.bind(this, ...args),\n      };\n      buckets.set(af, bucket);\n    } else {\n      bucket.nSSI = 0;\n      bucket.nEI = 0;\n      bucket.nMI = 0;\n      bucket.af = af.bind(this, ...args);\n    }\n\n    let r;\n    try {\n      r = fns.apply(this, args);\n    } finally {\n      // run (cleanups and) effects, if any\n      try {\n        runEffects(bucket);\n\n        return cb(r);\n      } finally {\n        if (bucket.hUS) {\n          bucket.hUS = false;\n          bucket.af();\n        }\n\n        afStack.pop();\n      }\n    }\n  }\n\n  function runEffects(bucket: Bucket) {\n    for (let [idx, [effect]] of bucket.e.entries()) {\n      try {\n        fnWrap(effect);\n      } finally {\n        bucket.e[idx][0] = undefined;\n      }\n    }\n  }\n\n  function reset() {\n    afStack.push(af);\n    const bucket = getCurrentBucket();\n    try {\n      // run all pending cleanups\n      for (let cleanup of bucket.c) {\n        fnWrap(cleanup);\n      }\n    } finally {\n      afStack.pop();\n      bucket.sS.length = 0;\n      bucket.e.length = 0;\n      bucket.c.length = 0;\n      bucket.m.length = 0;\n      bucket.nSSI = 0;\n      bucket.nEI = 0;\n      bucket.nMI = 0;\n      //TODO: cleanup af\n    }\n  }\n}\n\nexport function useState<T>(initialVal?: T | ((v: T) => T)): [T, (data: T | ((v: T) => T)) => T] {\n  return useReducer<T>(function reducer(prevVal: T, vOrFn: (arg0: any) => T) {\n    return fnWrap(vOrFn, [prevVal]);\n  }, initialVal);\n}\n\nexport function useReducer<T>(\n  reducer: { (prevVal: any, vOrFn: any): any; (arg0: any, arg1: any): any },\n  initialVal?: T | ((v: T) => T),\n  ...initialReduction: undefined[]\n): [T, (data: T | ((v: T) => T)) => T] {\n  var bucket = getCurrentBucket();\n\n  // need to create this state-slot for this bucket?\n  if (!(bucket.nSSI in bucket.sS)) {\n    let slot: [any, (v: any) => any] = [\n      fnWrap(initialVal),\n      function updateSlot(v: any) {\n        slot[0] = reducer(slot[0], v);\n        // if a state was changed:\n        // - immediately => set the hasUpdatedState flat\n        // - after main threat was done => invoke AF\n        afStack.length > 0 ? (bucket.hUS = true) : bucket.af();\n      },\n    ];\n    bucket.sS[bucket.nSSI] = slot;\n\n    // run the reducer initially?\n    if (initialReduction.length > 0) {\n      bucket.sS[bucket.nSSI][1](initialReduction[0]);\n    }\n  }\n\n  return [...bucket.sS[bucket.nSSI++]];\n}\n\nexport function useEffect(fn: () => any, ...guards: any[][]) {\n  // passed in any guards?\n  if (guards.length > 0) {\n    // only passed a single guards list?\n    if (guards.length == 1 && Array.isArray(guards[0])) {\n      guards = guards[0];\n    }\n  }\n  // no guards passed\n  // NOTE: different handling than an empty guards list like []\n  else {\n    guards = undefined as any;\n  }\n\n  const bucket = getCurrentBucket();\n\n  // need to create this effect-slot for this bucket?\n  if (!(bucket.nEI in bucket.e)) {\n    bucket.e[bucket.nEI] = [];\n  }\n\n  let effectIdx = bucket.nEI;\n  let effect = bucket.e[effectIdx];\n\n  // check guards?\n  if (guardsChanged(effect[1], guards)) {\n    // define effect handler\n    effect[0] = function effect() {\n      // run a previous cleanup first?\n\n      // if (typeof bucket.cleanups[effectIdx] == 'function') {\n      try {\n        // bucket.cleanups[effectIdx]();\n        fnWrap(bucket.c[effectIdx]);\n      } finally {\n        bucket.c[effectIdx] = undefined;\n      }\n      // }\n\n      // invoke the effect itself\n      var ret = fn();\n\n      // cleanup function returned, to be saved?\n      if (typeof ret == 'function') {\n        bucket.c[effectIdx] = ret;\n      }\n    };\n    effect[1] = guards;\n  }\n\n  bucket.nEI++;\n}\n\nexport function useMemo<T>(fn: () => T, ...inputGuards: (any | { (): any })[]) {\n  // passed in any input-guards?\n  if (inputGuards.length > 0) {\n    // only passed a single inputGuards list?\n    if (inputGuards.length == 1 && Array.isArray(inputGuards[0])) {\n      inputGuards = inputGuards[0];\n    }\n  }\n  // no input-guards passed\n  // NOTE: different handling than an empty inputGuards list like []\n  else {\n    // the function itself is then used as the only input-guard\n    inputGuards = [fn];\n  }\n\n  const bucket = getCurrentBucket();\n\n  // need to create this memoization-slot for this bucket?\n  if (!(bucket.nMI in bucket.m)) {\n    bucket.m[bucket.nMI] = [];\n  }\n\n  const memoization = bucket.m[bucket.nMI];\n\n  // check input-guards?\n  if (guardsChanged(memoization[1], inputGuards)) {\n    try {\n      // invoke the to-be-memoized function\n      memoization[0] = fn();\n    } finally {\n      // save the new input-guards\n      memoization[1] = inputGuards;\n    }\n  }\n\n  bucket.nMI++;\n\n  // return the memoized value\n  return memoization[0];\n}\n\nexport function useCallback<T>(fn: T, ...inputGuards: any[]): T {\n  return useMemo(function cb() {\n    return fn;\n  }, ...inputGuards);\n}\n\nexport function useRef<T>(initialValue: T) {\n  // create a new {} object with a `current` property,\n  // save it in a state slot\n  var [ref] = useState({ current: initialValue });\n  return ref;\n}\n"]}
import{fnWrap}from"./utils";const buckets=new WeakMap,afStack=[];function getCurrentBucket(){const af=afStack[afStack.length-1],bucket=buckets.get(af);if(void 0!==bucket)return bucket;throw new Error("Hooks only valid inside an Articulated Function or a Custom Hook.")}function guardsChanged(guards1,guards2){if(void 0===guards1||void 0===guards2)return!0;if(guards1.length!==guards2.length)return!0;for(const[idx,guard]of guards1.entries())if(!Object.is(guard,guards2[idx]))return!0;return!1}export function AF(fns,cb){return af.reset=function(){afStack.push(af);const bucket=getCurrentBucket();try{for(let cleanup of bucket.c)fnWrap(cleanup)}finally{afStack.pop(),bucket.sS.length=0,bucket.e.length=0,bucket.c.length=0,bucket.m.length=0,bucket.nSSI=0,bucket.nEI=0,bucket.nMI=0}},af;function af(...args){afStack.push(af);let r,bucket=buckets.get(af);null==bucket?(bucket={nSSI:0,nEI:0,nMI:0,sS:[],e:[],c:[],m:[],hUS:!1,af:af.bind(this,...args)},buckets.set(af,bucket)):(bucket.nSSI=0,bucket.nEI=0,bucket.nMI=0,bucket.af=af.bind(this,...args));try{r=fns.apply(this,args)}finally{try{return function(bucket){for(let[idx,[effect]]of bucket.e.entries())try{fnWrap(effect)}finally{bucket.e[idx][0]=void 0}}(bucket),cb(r)}finally{bucket.hUS&&(bucket.hUS=!1,bucket.af()),afStack.pop()}}}}export function useState(initialVal){return useReducer((function(prevVal,vOrFn){return fnWrap(vOrFn,[prevVal])}),initialVal)}export function useReducer(reducer,initialVal,...initialReduction){var bucket=getCurrentBucket();if(!(bucket.nSSI in bucket.sS)){let slot=[fnWrap(initialVal),function(v){slot[0]=reducer(slot[0],v),afStack.length>0?bucket.hUS=!0:bucket.af()}];bucket.sS[bucket.nSSI]=slot,initialReduction.length>0&&bucket.sS[bucket.nSSI][1](initialReduction[0])}return[...bucket.sS[bucket.nSSI++]]}export function useEffect(fn,...guards){guards.length>0?1==guards.length&&Array.isArray(guards[0])&&(guards=guards[0]):guards=void 0;const bucket=getCurrentBucket();bucket.nEI in bucket.e||(bucket.e[bucket.nEI]=[]);let effectIdx=bucket.nEI,effect=bucket.e[effectIdx];guardsChanged(effect[1],guards)&&(effect[0]=function(){try{fnWrap(bucket.c[effectIdx])}finally{bucket.c[effectIdx]=void 0}var ret=fn();"function"==typeof ret&&(bucket.c[effectIdx]=ret)},effect[1]=guards),bucket.nEI++}export function useMemo(fn,...inputGuards){inputGuards.length>0?1==inputGuards.length&&Array.isArray(inputGuards[0])&&(inputGuards=inputGuards[0]):inputGuards=[fn];const bucket=getCurrentBucket();bucket.nMI in bucket.m||(bucket.m[bucket.nMI]=[]);const memoization=bucket.m[bucket.nMI];if(guardsChanged(memoization[1],inputGuards))try{memoization[0]=fn()}finally{memoization[1]=inputGuards}return bucket.nMI++,memoization[0]}export function useCallback(fn,...inputGuards){return useMemo((function(){return fn}),...inputGuards)}export function useRef(initialValue){var[ref]=useState({current:initialValue});return ref}